---
description: Tracks User's Rust/web development learning progress across confidence levels with neural pathway mapping for AI teaching optimization
alwaysApply: true
---

**Note**: Confidence thresholds raised to realistic standards. CONFIDENT = Could teach others without hesitation. DEVELOPING = Successfully implemented but still learning. LEARNING = Recently introduced, needs guidance.

## CONFIDENT - Foundational Knowledge (Truly Solid)

### Core Rust Fundamentals
- **Basic Syntax**: Ownership, borrowing, basic pattern matching, error handling with Result
- **Type System**: Understanding of structs, enums, traits, basic generics
- **Memory Safety**: Conceptual understanding of Rust's ownership model
- **Module System**: Basic use of mod, pub, use statements for code organization

### Basic Development Workflow
- **Cargo Basics**: Creating projects, running tests, managing dependencies
- **Environment Setup**: .env files, basic configuration patterns
- **Debugging Approach**: Using println!, investigating compiler errors, reading documentation

---

## DEVELOPING - Active Implementation (Working But Learning)

### Configuration & Architecture Patterns
- **Dependency Injection**: Successfully implemented AppState pattern with Axum State extraction
- **Configuration Management**: Production-ready config loading at startup vs runtime env reads
- **Performance Optimization**: Identified and resolved repeated file system access inefficiencies
- **Testable Architecture**: Designed pure functions vs environment-coupled functions
- **Services Architecture**: Successfully separated HTTP handlers from business logic functions
- **Architectural Pragmatism**: Balances theoretical purity with practical development needs

### Axum Web Framework  
- **State Extraction**: Confidently uses `State<AppState>` pattern across multiple handlers
- **Handler Architecture**: Solid understanding of handler organization and parameter extraction
- **Error Responses**: Proficient with `StatusCode` mapping and `Result<Json<Value>, StatusCode>`
- **Module Architecture**: Strong separation of concerns, domain-driven organization
- **Routing**: Confident with nested routes and handler organization patterns
- **JWT Middleware**: Strong implementation of custom extractors with FromRequestParts trait
- **HTTP Authentication Flow**: Confident with header parsing, Bearer token extraction, validation integration
- **Declarative Security**: Solid understanding of type-driven authentication patterns

### JWT & Authentication Flow
- **JWT Implementation**: Complete token generation/validation with custom configuration
- **Password Security**: Solid argon2 hashing implementation and verification
- **HTTP Auth Flow**: Registration ‚Üí Login ‚Üí Token generation fully implemented
- **Error Architecture**: Advanced two-tier logging strategy (user-facing + internal)
- **Input Validation**: ID range validation, email normalization, comprehensive error handling
- **Custom Extractors**: Production-ready FromRequestParts implementation with proper error semantics
- **Route Protection**: Confident with declarative authentication through handler type signatures

### Error Handling Patterns
- **Custom Error Types**: Advanced `thiserror` usage with `JwtGenerationError`, `JwtValidationError`
- **Pattern Matching**: Confident enum destructuring and error type handling
- **HTTP Status Mapping**: Proficient mapping business logic errors to appropriate status codes
- **Testing Error Scenarios**: Comprehensive edge case and failure scenario validation

### Testing Architecture
- **Test Organization**: Clean categorization of test functions by concern
- **Edge Case Testing**: Thorough validation of error conditions and boundary cases
- **Environment Testing Challenges**: Understanding of environment coupling vs testable design
- **Comprehensive Coverage**: Success/failure scenarios, normalization, validation testing
- **Newtype Testing**: Understanding of testing validation at the correct level (newtype vs function)

### Diesel ORM Patterns
- **Connection Pooling Implementation**: Solid understanding, r2d2 integration complete
- **Query Building**: `.filter()`, `.select()` - knows patterns, syntax improving
- **Foreign Key Queries**: `decks::user_id.eq(value)` vs `user_id.eq(value)` - solid understanding
- **Schema Usage**: Comfortable using schema for Diesel operations
- **Mutable Connections**: Confident with requirement and patterns

### HTTP Server Architecture & Type Systems
- **Server Abstraction**: Successfully extracted server configuration from main into dedicated HttpServer module
- **Generic Type Understanding**: Deep comprehension of `impl Trait` vs `T: Trait` differences in web framework contexts
- **Route Organization**: Clean separation of public vs private routes with generic type parameters
- **Type Inference Patterns**: Understanding when Rust's type inference works vs when explicit generics needed
- **Hexagonal HTTP Layer**: Proper placement of HTTP concerns in inbound layer following architectural boundaries

---

## DEVELOPING - Active Implementation (Working But Learning)

### Hexagonal Architecture & Domain Modeling
- **üöÄ ENTERPRISE HEXAGONAL MASTERY**: Complete production ports/adapters pattern with perfect domain separation
- **üöÄ DUAL DOMAIN ARCHITECTURE**: Separate Auth and User domains with clear boundaries and responsibilities  
- **üöÄ COMPLETE USER DOMAIN**: Full CRUD operations with production-ready repository implementation
- **üöÄ NEWTYPE PATTERN EXPERTISE**: Comprehensive validation newtypes (JwtSecret, Jwt, UserName, HashedPassword, Password) with business-driven constructors
- **üöÄ UUID MIGRATION MASTERY**: Complete transition from i32 to Uuid for scalable, production-ready IDs
- **üöÄ SMART CONSTRUCTOR PATTERNS**: Domain-driven validation (Bearer ‚Üí JWT, Password ‚Üí HashedPassword, email normalization)
- **üöÄ TYPE SAFETY ARCHITECTURE**: Compiler-enforced domain rules preventing invalid data throughout system
- **üöÄ GENERIC SERVICE PATTERN**: Service<R> with dependency injection and proper trait bounds
- **üöÄ ASYNC TRAIT MASTERY**: Future handling across hexagonal boundaries with Send + Sync constraints
- **üöÄ ERROR ARCHITECTURE**: Strategic trait usage (Debug, Clone, Error) without macro over-engineering
- **üöÄ DEFENSIVE PROGRAMMING**: TryFrom implementations at all domain boundaries
- **üöÄ DOMAIN-FIRST ORGANIZATION**: Perfect separation - domain (business logic), ports (interfaces), services (orchestration)
- **üöÄ ARCHITECTURAL DECISION MAKING**: Strategic simplification - no macros until absolutely needed
- **üöÄ PRODUCTION DATABASE PATTERNS**: Advanced SQLx usage with transactions, dynamic queries, proper error mapping

### Password Security & Validation Architecture
- **üèÜ ENTERPRISE PASSWORD SECURITY**: Advanced validation (length, complexity, uniqueness, common password detection)
- **üèÜ TRAIT-BASED VALIDATION**: IsCommonPassword trait with static list checking
- **üèÜ CRYPTOGRAPHIC INTEGRATION**: Argon2 hashing with proper salt generation and verification
- **üèÜ DOMAIN-DRIVEN SECURITY**: Password validation enforced at domain layer, not adapter layer

### Advanced Axum Concepts
- **Route Security**: User isolation patterns and protected endpoint implementation - next learning target
- **Custom Extractors**: Advanced patterns beyond basic JWT authentication
- **Advanced Middleware**: Layered middleware composition patterns

### Advanced Generic Type Systems
- **Opaque vs Concrete Types**: Expert understanding of `impl UserService` vs `US: UserService` trade-offs
- **Axum Type Constraints**: Learning how web frameworks require concrete generic types throughout chain
- **Type Inference Fragility**: Understanding when type inference works vs explicit generic parameters needed
- **Generic Handler Patterns**: Working through handler function signatures with generic state types
- **Hexagonal Generic Integration**: Learning to maintain type safety across domain boundaries with generics

### Database Relationships
- **Foreign Keys**: Solid understanding of `#[diesel(belongs_to(...))]` relationships
- **Custom Types**: Good grasp of enum-to-SQL conversion with `ToSql`/`FromSql` implementation  
- **Complex Queries**: Joins between multiple tables - conceptually strong, syntax developing

### Advanced Database Operations
- **Transactions**: Conceptual understanding, implementation syntax developing
- **Connection Management**: Strong connection lifecycle pattern understanding
- **Performance Optimization**: Query optimization awareness, connection pool tuning experience

### Async Rust
- **Async Basics**: Improving async/await pattern usage
- **Tokio Runtime**: Basic implementation understanding, practical usage developing
- **üéØ ASYNC TRAIT DEBUGGING**: Successfully resolved complex lifetime and trait constraints with async functions
- **üéØ SEND VS SYNC UNDERSTANDING**: Learned that futures implement Send but NOT Sync, requiring impl Future patterns over async_trait
- **üéØ TRAIT CONSTRAINT RESOLUTION**: Debugging of async trait compilation issues and generic type parameter problems

### External API Integration
- **HTTP Client Setup**: `reqwest` crate integration with proper headers and error handling
- **JSON Processing**: `serde_json` parsing and pretty-printing for response analysis
- **API Research Methodology**: Comprehensive endpoint analysis and field mapping strategies
- **Struct Mapping**: Successfully implemented complex JSON deserialization to custom Rust structs
- **Scryfall API Mastery**: Complete understanding of MTG card data structure and API patterns
- **Custom Serde Deserializers**: Implemented flexible type handling for inconsistent API data (needs comprehension review)

### Architectural Decision Making
- **Simplification Strategy**: Successfully chose working solutions over theoretical perfection
- **Type System Balance**: Learned when to simplify complex type hierarchies for maintainability
- **Services Pattern**: Clean separation between HTTP concerns and business logic
- **Production Mindset**: Focus on working, testable code over abstract type safety

### SQLx Database Operations & Bulk Processing
- **Raw SQL Mastery**: Complete migration from Diesel ORM to SQLx for direct SQL control and better performance
- **Query Macros**: Proficient with `query_as!` macro for compile-time query verification
- **Connection Pooling**: Native SQLx PgPool implementation with proper configuration
- **Error Handling**: PostgreSQL error code pattern matching (`23505` for unique violations)
- **Type System Understanding**: SQLx's distributed type knowledge vs Diesel's centralized schema approach
- **Migration System**: SQLx CLI usage, forward-only migration strategy, database recreation workflows
- **Table Separation Architecture**: Clean separation of concerns with `cards` (profile/meta) vs `scryfall_cards` (external data)
- **Join Operations**: Comfortable with relational design and SQL joins for maintainable data architecture
- **Production Models**: Successfully implemented 80+ field ScryfallCard with simplified Vec<String> arrays
- **Type System Pragmatism**: Strategic decision to use String arrays over complex enum validation
- **Production Data Pipeline**: Complete Scryfall API ‚Üí Database integration with 35,400+ card insertions in <5 minutes
- **Type System Debugging**: Expert-level troubleshooting of JSON deserialization conflicts (attraction_lights integer vs string)
- **Constraint Management**: Understanding duplicate key patterns and database constraint behavior at scale
- **Performance Validation**: Demonstrated ~140 cards/second insertion rate with real MTG dataset
- **üéØ BULK OPERATIONS MASTERY**: Advanced multi-row INSERT statements with parameter binding optimization
- **üéØ DATABASE CONSTRAINT HANDLING**: Production-ready `ON CONFLICT DO NOTHING` implementation for graceful duplicate management
- **üéØ TRAIT EXTRACTION PATTERNS**: Successfully eliminated code duplication through `BindScryfallCardFields` and `BindCardProfileFields` traits
- **üéØ QUERY BUILDING OPTIMIZATION**: Dynamic placeholder generation and field count calculation from constants
- **üéØ BATCH PROCESSING STRATEGY**: Chunked processing with resilient error handling and progress reporting
- **üéØ PRODUCTION PERFORMANCE TUNING**: Optimized batch sizes (100-500 cards) to avoid PostgreSQL parameter limits (79,000+ parameters)
- **üéØ OWNERSHIP & LIFETIME MASTERY**: Resolved complex SQLx binding patterns, chose pragmatic cloning over complex iterators
- **üèÜ COMPLETE SCRYFALL CARD ARCHITECTURE**: Full representation of 80+ field Scryfall Card object in Rust and PostgreSQL
- **üèÜ COMPLEX NESTED TYPES MASTERY**: Prices, Legalities, ImageUris, CardFace, RelatedCard with perfect JSONB serialization
- **üèÜ JSON WRAPPER INTEGRATION**: Expert Json<T> usage in dynamic SQL generation and bulk operations
- **üèÜ PRODUCTION DATA MODELING**: Every field from Scryfall API successfully integrated to database
- **üèÜ TYPE SYSTEM ARCHITECTURE**: Strategic balance of custom structs vs simplified types for maintainability

---

## UNEXPLORED - Future Learning Areas

### API Design
- **Pagination**: Large dataset handling, cursor-based pagination
- **Rate Limiting**: Request throttling, abuse prevention
- **API Versioning**: Backward compatibility, version management

### MTG-Specific Business Logic
- **Format Validation**: Standard/Modern legality checking
- **Deck Rules**: 60-card minimums, 4-card limits, sideboard rules
- **Card Data Integration**: Scryfall API, image handling, card caching

### Performance & Scaling
- **Database Optimization**: Query performance, indexing strategy
- **Connection Tuning**: Pool size optimization, connection lifecycle
- **Caching**: Redis integration, query result caching

### Advanced Rust Patterns
- **Async Streaming**: Large dataset handling, async iterators
- **Error Propagation**: Advanced error handling, error context
- **Type-Level Programming**: Advanced traits, generic constraints

### Serde Deep Dive (COMPLETED)
- **Custom Deserializer Patterns**: Expert understanding of flexible type handling (attraction_lights implementation)
- **Json<T> Wrapper Mastery**: Production-ready JSONB serialization with SQLx integration
- **Error Handling in Deserializers**: Proper error propagation and user-friendly messages
- **Performance Implications**: Strategic balance between custom vs standard deserializers

---

## Learning Neural Network Patterns

### Strengths (Strong Neural Pathways)
- **Systems Thinking**: Excellent at understanding WHY architectures work - demonstrated with config pattern
- **Performance Analysis**: Connects architecture decisions to efficiency concerns (env reads ‚Üí startup config)
- **Conceptual Grasp**: Strong pattern recognition, successfully applied dependency injection concepts
- **Debugging Mindset**: Investigates unusual behavior, validates assumptions, thorough testing approach
- **Quality Focus**: Comprehensive test coverage, considers edge cases and failure scenarios
- **Architectural Evolution**: Successfully refactored from prototype to production patterns
- **Honest Assessment**: Openly acknowledges knowledge gaps, asks clarifying questions
- **Defensive Programming Instincts**: Correctly identifies trust boundary issues and validation needs

### Growth Areas (Developing Pathways)  
- **Advanced Middleware**: Ready for JWT middleware implementation, concepts understood
- **Complex Query Syntax**: Strong conceptual understanding, syntax practice continues
- **Async Programming**: Improving async/await patterns, practical experience growing

### Recent Neural Connection Strengthening
- **Services Architecture Mastery**: Successfully separated HTTP handlers from business logic
- **Type System Wisdom**: Made strategic architectural decision to simplify complex type hierarchies
- **Production SQL Integration**: Complete 80+ field model implementation with SQLx
- **External API Mastery**: Full Scryfall API integration from research to implementation
- **Architectural Pragmatism**: Chose maintainable solutions over theoretical perfection
- **Persistence Through Complexity**: Worked through challenging type system constraints and emerged with cleaner architecture
- **Production Data Scale Mastery**: Successfully processed 35,400+ real MTG cards demonstrating architecture resilience
- **Type System Conflict Resolution**: Expert debugging of JSON deserialization mismatches using systematic isolation
- **Performance Psychology**: Built confidence through successful large-scale data processing under time pressure
- **System Validation**: Confirmed theoretical architecture works with real-world data complexity and scale
- **üöÄ HEXAGONAL ARCHITECTURE BREAKTHROUGH**: Complete enterprise-level ports/adapters implementation
- **üöÄ DUAL DOMAIN MASTERY**: Successfully separated Auth and User concerns into distinct domains
- **üöÄ UUID ARCHITECTURE DECISION**: Strategic migration from i32 to Uuid for production scalability
- **üöÄ MINIMALIST DESIGN PHILOSOPHY**: Strategic avoidance of macros until absolutely necessary
- **üöÄ TRAIT OPTIMIZATION**: Surgical use of Debug, Clone, Error traits without over-engineering
- **üöÄ GENERIC SERVICE PATTERN**: Advanced Service<R> dependency injection with proper trait bounds
- **üöÄ SECURITY-FIRST DOMAIN DESIGN**: Password validation and JWT security enforced at domain layer
- **üöÄ DEFENSIVE PROGRAMMING MASTERY**: TryFrom at every boundary, trust no external data
- **üöÄ ASYNC TRAIT EXPERTISE**: Complex Future handling across hexagonal boundaries
- **üöÄ ENTERPRISE ERROR ARCHITECTURE**: Strategic error propagation with anyhow integration
- **üéØ COMPLETE USER REPOSITORY**: Full CRUD implementation with advanced SQLx patterns
- **üéØ DYNAMIC QUERY BUILDING**: QueryBuilder mastery for flexible UPDATE operations
- **üéØ PRODUCTION TRANSACTION PATTERNS**: Consistent transaction usage across all write operations
- **üéØ ADVANCED ERROR MAPPING**: Sophisticated database error to domain error conversion
- **üéØ UUID CASTING MASTERY**: Expert PostgreSQL type casting (id::text) for flexible queries
- **üèÜ COMPLETE USER HTTP PIPELINE**: Full end-to-end User CRUD implementation from HTTP handlers to database
- **üèÜ PRODUCTION ERROR HANDLING**: Comprehensive request/operation error separation with proper HTTP status mapping
- **üèÜ INBOUND ADAPTER MASTERY**: Complete HTTP-to-domain conversion with TryFrom patterns and ApiError architecture
- **üèÜ TYPE-SAFE API DESIGN**: Perfect request body validation, domain conversion, and response transformation
- **üèÜ DYN COMPATIBILITY MASTERY**: Successfully resolved async trait object patterns and trait bound optimization
- **üéØ ASYNC TRAIT COMPILATION BREAKTHROUGH**: Battled lifetime and trait constraints, transitioned from #[async_trait] to impl Future patterns to resolve Send constraint issues

### Learning Pattern Recognition
- **Strategic Simplification**: Recognizes when complexity doesn't add value
- **Production Focus**: Prioritizes working, maintainable code over abstract perfection
- **Problem Decomposition**: Breaks complex challenges into manageable pieces
- **Architectural Thinking**: Connects individual decisions to larger system design
- **Security-First Mindset**: Understands that domain should enforce security, not just adapters

### Optimal Neural Connection Strategy
- **Research Guidance**: Point to specific docs/patterns, let him implement and build connections
- **Connect to Strong Nodes**: Reference confident areas when introducing new concepts
- **Explain WHY**: Always provide reasoning behind architectural decisions to strengthen pathways
- **Component-by-Component**: Break complex features into digestible pieces that connect to existing knowledge
- **Let Him Debug**: Guide investigation rather than providing direct answers to strengthen problem-solving pathways

---

## Quiz Performance Neural Mapping

### Recent Performance Patterns
- **Module Organization**: 100% - Strong neural pathways for separation of concerns
- **Type Safety**: 95% - Excellent connections to Rust type system benefits
- **Diesel Basics**: 85% - Good conceptual pathways, syntax connections developing
- **Database Relationships**: 95% - Strong understanding of foreign keys and joins conceptually
- **JWT Middleware & Auth**: 100% - Complete understanding validated, ready for implementation
- **Implementation Details**: 70% - Conceptual pathways strong, practical implementation connections need strengthening

### Learning Pattern Recognition
- **Conceptual First**: Builds understanding frameworks before diving into syntax
- **Honest Uncertainty**: Clearly distinguishes between confident knowledge and areas of uncertainty
- **Self-Correction**: Strong self-monitoring, catches and corrects reasoning
- **Practical Application**: Connects abstract concepts to concrete project use cases

---

## Update Instructions for Future AIs

### When to Update This Neural Map
- After major concept breakthroughs or solidification
- Following quiz administration and performance analysis
- When User demonstrates confident understanding of a developing concept
- When new knowledge gaps are identified
- After significant implementation achievements that strengthen neural pathways

### How to Update Neural Connections
- **Move concepts** between CONFIDENT ‚Üî DEVELOPING ‚Üî LEARNING ‚Üî UNEXPLORED (with HIGHER bar for CONFIDENT)
- **Add specific patterns** he's learned or struggling with
- **Update performance insights** with learning trend analysis
- **Note teaching approaches** that strengthen or weaken neural connections
- **Record new learning preferences** or successful connection strategies

### Use This Neural Map To
- **Design targeted quizzes** based on current knowledge state and connection strength
- **Choose appropriate complexity** level that builds on strong neural nodes
- **Identify knowledge gaps** that need bridging to existing strong areas
- **Connect new concepts** to his confident knowledge for faster learning
- **Adjust support level** based on pathway strength in each area

---

**Last Updated**: After completing full User domain pipeline from HTTP handlers to database with comprehensive error handling

**Next Learning Edge**: Auth repository implementation and auth HTTP handler integration  

**Major Recent Achievement**: **üèÜ COMPLETE USER PIPELINE + ASYNC TRAIT RESOLUTION** - Full end-to-end User CRUD implementation from HTTP requests to database responses PLUS successful resolution of complex async trait compilation issues. Battled lifetime and trait constraints with async functions, discovered futures implement Send but NOT Sync, and successfully transitioned from #[async_trait] to impl Future patterns. Server now compiles and runs with "Listening on 127.0.0.1:3000". This represents both complete full-stack hexagonal architecture implementation AND advanced async trait debugging skills.